# 구간합 (Prefix Sum)

> 한 줄 요약: 배열의 특정 구간의 합을 O(1) 시간에 빠르게 구하는 알고리즘

## 📌 목차
- [개요](#개요)
- [동작 원리](#동작-원리)
- [시간/공간 복잡도](#시간공간-복잡도)
- [구현 (Java)](#구현-java)
- [구현 (Kotlin)](#구현-kotlin)
- [적용 문제 유형](#적용-문제-유형)
- [최적화 기법](#최적화-기법)
- [관련 알고리즘](#관련-알고리즘)

---

## 개요

### 문제 상황
- **입력**: 배열 arr와 여러 개의 구간 쿼리 [i, j]
- **출력**: 각 구간의 합 (arr[i] + arr[i+1] + ... + arr[j])
- **문제**: 매번 반복문으로 계산하면 쿼리마다 O(N) 시간 소요

### 핵심 아이디어
누적 합 배열을 미리 계산해두면, 어떤 구간의 합도 **단 한 번의 뺄셈**으로 구할 수 있습니다.

```
prefixSum[i] = arr[0] + arr[1] + ... + arr[i]
구간 [i, j]의 합 = prefixSum[j] - prefixSum[i-1]
```

### 언제 사용하는가?
- ✅ 구간 합 쿼리가 여러 번 발생하는 경우
- ✅ 배열이 변경되지 않는 경우 (정적 배열)
- ✅ 슬라이딩 윈도우와 함께 사용
- ✅ 2차원 배열의 부분 합 구하기
- ❌ 배열이 자주 변경되는 경우 (세그먼트 트리 사용)
- ❌ 구간 합 쿼리가 1~2번만 발생하는 경우

---

## 동작 원리

### 단계별 설명

#### Step 1: 누적 합 배열 생성
```
원본 배열:     [10, 20, 30, 40, 50]
누적 합 배열:  [10, 30, 60, 100, 150]
                ↑   ↑   ↑    ↑     ↑
               10  10+20 ... ...  sum(0~4)
```

#### Step 2: 구간 합 계산
```
구간 [1, 3]의 합을 구하려면?
prefixSum[3] - prefixSum[0] = 100 - 10 = 90
즉, 20 + 30 + 40 = 90 ✅
```

#### Step 3: 예외 처리
```
구간 [0, 2]의 합을 구하려면?
i = 0이면 prefixSum[i-1]은 존재하지 않으므로
그냥 prefixSum[j]를 반환
```

### 시각화 예제

```
입력 배열: [10, 20, 30, 40, 50]
인덱스:     0   1   2   3   4

누적 합 생성:
prefixSum[0] = 10
prefixSum[1] = prefixSum[0] + 20 = 30
prefixSum[2] = prefixSum[1] + 30 = 60
prefixSum[3] = prefixSum[2] + 40 = 100
prefixSum[4] = prefixSum[3] + 50 = 150

쿼리: 구간 [2, 4]의 합?
답: prefixSum[4] - prefixSum[1] = 150 - 30 = 120
검증: 30 + 40 + 50 = 120 ✅
```

---

## 시간/공간 복잡도

| 작업 | 시간 복잡도 | 공간 복잡도 |
|------|-----------|-----------|
| 전처리 (누적 합 생성) | O(N) | O(N) |
| 구간 합 쿼리 | O(1) | - |
| 총 복잡도 (Q개 쿼리) | O(N + Q) | O(N) |

### 복잡도 분석
- **시간 복잡도**:
  - 누적 합 배열 생성에 O(N)
  - 각 쿼리는 단순 뺄셈이므로 O(1)
  - 총 Q개의 쿼리 처리 시 O(N + Q)
  - 일반 방법(O(N×Q))보다 훨씬 빠름

- **공간 복잡도**:
  - 누적 합 배열을 위한 O(N) 추가 메모리 필요
  - 원본 배열 위에 덮어쓰면 O(1)로 줄일 수 있음 (단, 원본 손실)

---

## 구현 (Java)

### 기본 구현 (1차원)
```java
public class PrefixSum {
    private int[] prefixSum;

    /**
     * 누적 합 배열을 생성하는 생성자
     * @param arr 원본 배열
     */
    public PrefixSum(int[] arr) {
        int n = arr.length;
        prefixSum = new int[n];

        prefixSum[0] = arr[0];
        for (int i = 1; i < n; i++) {
            prefixSum[i] = prefixSum[i-1] + arr[i];
        }
    }

    /**
     * 구간 [left, right]의 합을 반환
     * @param left 시작 인덱스
     * @param right 끝 인덱스
     * @return 구간의 합
     */
    public int rangeSum(int left, int right) {
        if (left == 0) {
            return prefixSum[right];
        }
        return prefixSum[right] - prefixSum[left - 1];
    }

    public static void main(String[] args) {
        int[] arr = {10, 20, 30, 40, 50};
        PrefixSum ps = new PrefixSum(arr);

        System.out.println(ps.rangeSum(1, 3)); // 90 (20+30+40)
        System.out.println(ps.rangeSum(0, 4)); // 150 (전체 합)
        System.out.println(ps.rangeSum(2, 2)); // 30 (단일 원소)
    }
}
```

### 2차원 구간합
```java
public class PrefixSum2D {
    private int[][] prefixSum;

    /**
     * 2차원 누적 합 배열 생성
     * @param matrix 2차원 배열
     */
    public PrefixSum2D(int[][] matrix) {
        int rows = matrix.length;
        int cols = matrix[0].length;
        prefixSum = new int[rows + 1][cols + 1];

        // (0,0)부터 (i,j)까지의 누적 합 계산
        for (int i = 1; i <= rows; i++) {
            for (int j = 1; j <= cols; j++) {
                prefixSum[i][j] = matrix[i-1][j-1]
                    + prefixSum[i-1][j]
                    + prefixSum[i][j-1]
                    - prefixSum[i-1][j-1];
            }
        }
    }

    /**
     * (x1,y1)부터 (x2,y2)까지의 구간 합
     * @return 구간의 합
     */
    public int rangeSum(int x1, int y1, int x2, int y2) {
        return prefixSum[x2+1][y2+1]
            - prefixSum[x1][y2+1]
            - prefixSum[x2+1][y1]
            + prefixSum[x1][y1];
    }
}
```

### Long 타입 버전 (오버플로우 방지)
```java
public class PrefixSumLong {
    private long[] prefixSum;

    public PrefixSumLong(int[] arr) {
        int n = arr.length;
        prefixSum = new long[n];

        prefixSum[0] = arr[0];
        for (int i = 1; i < n; i++) {
            prefixSum[i] = prefixSum[i-1] + arr[i];
        }
    }

    public long rangeSum(int left, int right) {
        if (left == 0) return prefixSum[right];
        return prefixSum[right] - prefixSum[left - 1];
    }
}
```

---

## 구현 (Kotlin)

### 기본 구현
```kotlin
class PrefixSum(arr: IntArray) {
    private val prefixSum: IntArray

    init {
        prefixSum = IntArray(arr.size)
        prefixSum[0] = arr[0]

        for (i in 1 until arr.size) {
            prefixSum[i] = prefixSum[i-1] + arr[i]
        }
    }

    /**
     * 구간 [left, right]의 합을 반환
     */
    fun rangeSum(left: Int, right: Int): Int {
        return if (left == 0) {
            prefixSum[right]
        } else {
            prefixSum[right] - prefixSum[left - 1]
        }
    }
}

fun main() {
    val arr = intArrayOf(10, 20, 30, 40, 50)
    val ps = PrefixSum(arr)

    println(ps.rangeSum(1, 3)) // 90
    println(ps.rangeSum(0, 4)) // 150
}
```

### 함수형 스타일 (Kotlin)
```kotlin
/**
 * 확장 함수로 누적 합 배열 생성
 */
fun IntArray.toPrefixSum(): IntArray {
    val result = IntArray(this.size)
    result[0] = this[0]

    for (i in 1 until this.size) {
        result[i] = result[i-1] + this[i]
    }

    return result
}

/**
 * 구간 합을 계산하는 확장 함수
 */
fun IntArray.rangeSum(left: Int, right: Int): Int {
    val prefixSum = this.toPrefixSum()
    return if (left == 0) {
        prefixSum[right]
    } else {
        prefixSum[right] - prefixSum[left - 1]
    }
}

// 사용 예시
fun main() {
    val arr = intArrayOf(10, 20, 30, 40, 50)
    println(arr.rangeSum(1, 3)) // 90

    // runningSum을 사용한 더 간결한 방법
    val prefixSum = arr.asSequence()
        .runningReduce { acc, value -> acc + value }
        .toList()

    println(prefixSum) // [10, 30, 60, 100, 150]
}
```

### 2차원 구간합 (Kotlin)
```kotlin
class PrefixSum2D(matrix: Array<IntArray>) {
    private val prefixSum: Array<LongArray>

    init {
        val rows = matrix.size
        val cols = matrix[0].size
        prefixSum = Array(rows + 1) { LongArray(cols + 1) }

        for (i in 1..rows) {
            for (j in 1..cols) {
                prefixSum[i][j] = matrix[i-1][j-1].toLong() +
                    prefixSum[i-1][j] +
                    prefixSum[i][j-1] -
                    prefixSum[i-1][j-1]
            }
        }
    }

    fun rangeSum(x1: Int, y1: Int, x2: Int, y2: Int): Long {
        return prefixSum[x2+1][y2+1] -
            prefixSum[x1][y2+1] -
            prefixSum[x2+1][y1] +
            prefixSum[x1][y1]
    }
}
```

---

## 적용 문제 유형

### 패턴 1: 기본 구간 합 쿼리

**문제 특징:**
- N개의 원소와 M개의 구간 쿼리가 주어짐
- 각 쿼리마다 [i, j] 구간의 합을 출력

**예시 문제:**
```
입력:
배열: [5, 4, 3, 2, 1]
쿼리: (0, 2), (1, 4), (0, 4)

출력:
12 (5+4+3)
10 (4+3+2+1)
15 (전체 합)
```

**솔루션:**
```java
import java.util.*;

public class RangeSum {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        int n = sc.nextInt(); // 배열 크기
        int m = sc.nextInt(); // 쿼리 개수

        int[] arr = new int[n];
        long[] prefixSum = new long[n];

        // 입력 및 누적 합 생성
        for (int i = 0; i < n; i++) {
            arr[i] = sc.nextInt();
            prefixSum[i] = (i == 0) ? arr[i] : prefixSum[i-1] + arr[i];
        }

        // 쿼리 처리
        for (int q = 0; q < m; q++) {
            int left = sc.nextInt();
            int right = sc.nextInt();

            long sum = (left == 0) ?
                prefixSum[right] :
                prefixSum[right] - prefixSum[left-1];

            System.out.println(sum);
        }
    }
}
```

### 패턴 2: 나머지 합 문제

**문제 특징:**
- 구간 합이 특정 수(M)로 나누어떨어지는 경우의 수
- (prefixSum[j] - prefixSum[i]) % M == 0
- → prefixSum[j] % M == prefixSum[i] % M

**예시 문제:**
```
문제: 구간 합이 3으로 나누어떨어지는 구간의 개수
배열: [1, 2, 3, 1, 2]
```

**솔루션:**
```java
public class RemainderSum {
    public int countDivisibleRanges(int[] arr, int m) {
        int n = arr.length;
        long[] prefixSum = new long[n + 1];

        // 누적 합 생성
        for (int i = 0; i < n; i++) {
            prefixSum[i+1] = prefixSum[i] + arr[i];
        }

        // 나머지별 개수 카운팅
        Map<Long, Integer> remainderCount = new HashMap<>();
        int result = 0;

        for (int i = 0; i <= n; i++) {
            long remainder = prefixSum[i] % m;

            // 같은 나머지를 가진 이전 위치들과 조합
            result += remainderCount.getOrDefault(remainder, 0);
            remainderCount.put(remainder,
                remainderCount.getOrDefault(remainder, 0) + 1);
        }

        return result;
    }
}
```

### 패턴 3: 2차원 구간 합

**문제 특징:**
- 2차원 배열에서 부분 행렬의 합 구하기
- (x1, y1)부터 (x2, y2)까지의 합

**솔루션:**
```kotlin
fun solution(matrix: Array<IntArray>, queries: List<Query>): List<Long> {
    val ps2d = PrefixSum2D(matrix)

    return queries.map { (x1, y1, x2, y2) ->
        ps2d.rangeSum(x1, y1, x2, y2)
    }
}

data class Query(val x1: Int, val y1: Int, val x2: Int, val y2: Int)
```

---

## 최적화 기법

### 1. 공간 최적화 (원본 배열 재사용)
```java
// 원본 배열이 필요없는 경우
public void optimizeSpace(int[] arr) {
    // 원본 배열을 누적 합 배열로 변환
    for (int i = 1; i < arr.length; i++) {
        arr[i] += arr[i-1];
    }
    // 이제 arr가 누적 합 배열
}
```

### 2. Long 타입 사용 (오버플로우 방지)
```kotlin
fun safePrefixSum(arr: IntArray): LongArray {
    val result = LongArray(arr.size)
    result[0] = arr[0].toLong()

    for (i in 1 until arr.size) {
        result[i] = result[i-1] + arr[i]
    }

    return result
}
```

### 3. 1-based 인덱싱으로 예외 처리 제거
```java
public class PrefixSumOneBased {
    private long[] prefixSum;

    public PrefixSumOneBased(int[] arr) {
        int n = arr.length;
        prefixSum = new long[n + 1]; // 크기를 1 증가

        // prefixSum[0] = 0 (기본값)
        for (int i = 0; i < n; i++) {
            prefixSum[i+1] = prefixSum[i] + arr[i];
        }
    }

    // left, right는 0-based 인덱스
    public long rangeSum(int left, int right) {
        // 예외 처리 필요없음!
        return prefixSum[right+1] - prefixSum[left];
    }
}
```

---

## 주의사항

### ⚠️ 흔한 실수

1. **실수 1: 인덱스 범위 오류**
   ```java
   // 잘못된 코드
   public int rangeSum(int left, int right) {
       return prefixSum[right] - prefixSum[left-1]; // left=0일 때 에러!
   }
   ```
   ❌ 문제점: left가 0일 때 prefixSum[-1] 접근 시도

   ```java
   // 올바른 코드
   public int rangeSum(int left, int right) {
       if (left == 0) return prefixSum[right];
       return prefixSum[right] - prefixSum[left-1];
   }
   ```
   ✅ 해결: left가 0인 경우 별도 처리

2. **실수 2: 오버플로우 무시**
   ```java
   // 잘못된 코드
   int[] prefixSum = new int[n]; // int 사용
   ```
   ❌ 문제점: 배열 크기가 크면 int 범위 초과

   ```java
   // 올바른 코드
   long[] prefixSum = new long[n]; // long 사용
   ```
   ✅ 해결: long 타입 사용

3. **실수 3: 2차원 구간합 공식 오류**
   ```java
   // 잘못된 공식
   sum = prefixSum[x2][y2] - prefixSum[x1][y2] - prefixSum[x2][y1];
   // 겹치는 부분을 빼지 않음!
   ```

   ```java
   // 올바른 공식
   sum = prefixSum[x2][y2]
       - prefixSum[x1-1][y2]
       - prefixSum[x2][y1-1]
       + prefixSum[x1-1][y1-1]; // 겹친 부분 다시 더하기
   ```

### 💡 팁

- **1-based 인덱싱**: 배열 크기를 1 증가시켜 경계 조건 처리를 단순화
- **Long 타입**: 문제에서 합이 클 것 같으면 무조건 long 사용
- **입력과 동시에 계산**: 입력 받으면서 누적 합 계산하면 시간 절약
- **2차원은 항상 헷갈림**: 그림 그려서 확인하기
- **모듈러 연산**: 나머지 합 문제는 해시맵과 함께 사용

### Edge Cases
- [x] 빈 배열: n=0 처리
- [x] 크기가 1인 배열: left=right=0
- [x] 전체 구간: left=0, right=n-1
- [x] 단일 원소 구간: left=right
- [x] 음수가 포함된 경우: 누적 합이 감소할 수 있음
- [x] 오버플로우: 배열 크기가 100,000이고 값이 10,000이면 int 초과

---

## 관련 알고리즘

### 비슷한 알고리즘
- [세그먼트 트리](./세그먼트트리.md) - 배열이 변경될 때는 세그먼트 트리 사용 (업데이트 O(log N))
- [펜윅 트리(BIT)](./펜윅트리.md) - 구간 합 + 업데이트를 지원하며 구현이 더 간단

### 함께 사용되는 기법
- [투 포인터](./투포인터.md) - 연속된 구간 문제에서 함께 사용
- [슬라이딩 윈도우](./슬라이딩윈도우.md) - 고정 크기 구간 문제
- [해시맵](../data-structures/해시맵.md) - 나머지 합 문제에서 개수 카운팅

---

## 연습 문제

### 난이도별 추천 문제

#### 🟢 Easy
1. [백준 11659 - 구간 합 구하기 4](https://www.acmicpc.net/problem/11659) - 1차원 기본 문제
2. [백준 2559 - 수열](https://www.acmicpc.net/problem/2559) - 슬라이딩 윈도우와 결합
3. [LeetCode 303 - Range Sum Query](https://leetcode.com/problems/range-sum-query-immutable/) - 기본 구간 합

#### 🟡 Medium
1. [백준 11660 - 구간 합 구하기 5](https://www.acmicpc.net/problem/11660) - 2차원 구간 합
2. [백준 10986 - 나머지 합](https://www.acmicpc.net/problem/10986) - 모듈러 연산 + 해시맵
3. [백준 16713 - Generic Queries](https://www.acmicpc.net/problem/16713) - XOR 누적 합
4. [LeetCode 304 - Range Sum Query 2D](https://leetcode.com/problems/range-sum-query-2d-immutable/) - 2차원 구간 합

#### 🔴 Hard
1. [백준 2143 - 두 배열의 합](https://www.acmicpc.net/problem/2143) - 구간 합 + 이분 탐색
2. [백준 1849 - 순열](https://www.acmicpc.net/problem/1849) - 펜윅 트리와 결합
3. [LeetCode 363 - Max Sum Rectangle](https://leetcode.com/problems/max-sum-of-rectangle-no-larger-than-k/) - 2D 구간 합 + 이분 탐색

### 문제 풀이 체크리스트
- [ ] 1차원 기본 구간 합 (백준 11659)
- [ ] 2차원 구간 합 (백준 11660)
- [ ] 나머지 합 문제 (백준 10986)
- [ ] 슬라이딩 윈도우와 결합 (백준 2559)
- [ ] Edge Case 처리 연습

---

## 참고 자료

### 추천 학습 자료
- [Do it! 알고리즘 코딩 테스트 - 자바편](https://www.youtube.com/watch?v=fw0fGWNJo-0) - 구간 합 기초
- [백준 온라인 저지 - 누적 합](https://www.acmicpc.net/problemset?sort=ac_desc&algo=139)
- [GeeksforGeeks - Prefix Sum Array](https://www.geeksforgeeks.org/prefix-sum-array-implementation-applications-competitive-programming/)

---

**작성일:** 2026-01-19
**최종 수정일:** 2026-01-19
**작성자:** 민순기
